# 이진 트리 Binary Tree

트리 구조 중 특수한 경우, 자식 노드가 두 개인 트리이다.

- 자식 노드 항상 2개 이내: 자식이 없을 수도, 왼쪽 자식 하나만 있거나, 오른쪽에 하나만 있을 수 있음
- 하부 트리도 동일한 구조이기 때문에 재귀 알고리즘으로 정의됨

# 이진 트리 성질

- 노드 수: n, 간선의 수: n-1
- 높이: h, 각 레벨의 최대 노드의 수: 2^h-1개 => 다 더하면 전체 레벨의 최대 노드 수

# 편향 이진 트리(skewed binary tree)

- 모든 노드가 부모의 왼쪽 자식, 왼쪽으로 편향 되어 있거나
  반대로 모든 노드가 부모의 오른쪽 자식, 오른쪽으로 편향 되어 있는 트리

![편향이진트리](https://user-images.githubusercontent.com/70371342/222063551-5d4fadf4-4fb8-47df-80b6-055ace9be8a3.png)

# 포화 이진 트리(full binary tree)

- 모든 노드가 자식 노드를 2개씩 다 가지고 있음 -> 각 레벨에서 이진 트리가 보유할 수 있는 최대의 노드를 가지고 있음.
- 루트를 제외한 왼쪽은 짝수, 오른쪽은 홀수의 노드 번호를 지님

![포화이진트리](https://user-images.githubusercontent.com/70371342/222063572-2c1da369-3fa3-4754-81d1-2d8d2ec8bbce.png)

# 완전 이진 트리(complete binary tree)

- 왼쪽부터 오른쪽까지 꽉 차서 노드의 수가 n<=(2^h-1)이라면 완전 이진 트리

![완전이진트리](https://user-images.githubusercontent.com/70371342/222063584-332f2f71-f566-4419-beb5-4d3487c1e05f.png)

# 이진 트리 순차 표현(배열 표현법)

- 완전 이진 트리를 표현할 때 사용
- 1차원 배열로 쉽게 표현
- 인덱스 0은 실제 사용하지 않고 인덱스 1은 항상 루트 노드를 나타낸다.

![이진트리의 순차표현1](https://user-images.githubusercontent.com/70371342/222063609-cca33792-3959-4698-83cc-c2aa991c9b89.png)

- 편향 이진 트리일 경우 메모리 공간의 낭비

![이진트리의 순차표현2](https://user-images.githubusercontent.com/70371342/222063629-9084b023-e358-47b1-935f-dd2630f265dd.png)

## 완전 이진 트리를 표현한 1차원 배열에서 인덱스 관계

| 목표 노드            | 인덱스 값 | 조건              |
| -------------------- | --------- | ----------------- |
| 노드 i의 부모        | [i / 2]   | i > 1             |
| 노드 i의 왼쪽자식    | 2 \* i    | 2 \* i <= n       |
| 노드 i의 오른쪽 자식 | 2 \* i +1 | (2 \* i + 1) <= n |
| 루트 노드            | 1         | 0 < n             |

# 이진 트리 연결 표현(링크 표현법)

- 저장 공간 효율적으로 사용하기 위해 링크드리스트 표현 사용
- 각 노드: left(왼쪽 서브 트리), data, right(오른쪽 서브 트리)을 포함하는 구조 가짐
- 각 노드를 방문할 수 있는 방법은 루트 노드 최상위에서 아래로 접근하기 때문에 이전 노드에 대한 정보는 필요 없고, 자식 노드에 대한 정보만 필요.

![이진트리 연결표현 노드 하나 구조](https://user-images.githubusercontent.com/70371342/222063655-3b0a070f-2ac2-434c-b7e6-8679f720c97a.png)

## 완전 이진 트리를 연결 표현으로 나타낸 것

- left와 right는 왼쪽 서브트리와 오른쪽 서브트리를 가리키는 포인터 필드, 서브트리가 공백이면 해당 노드는 null

![이진트리 연결표현](https://user-images.githubusercontent.com/70371342/222063680-ef016c57-65b0-4bf5-86fe-a44d07d4b3dd.png)

# 이진트리의 기본 순회(DFS)

- DFS로 구현되기 때문에 일단 파고든다는 점을 기억. 방문과 출력과 다르다는 것을 기억
- 피연산자가 앞에, 중간, 후에 들어가느냐에 따라 순회에서 루트를 언제 출력하느냐를 기준으로 3가지로 나뉨
- 루트의 출력 순서만 앞, 중간, 뒤로 바뀐다고 생각!
- 전위와 후위는 루트값을 바로 알 수 있다. 전위는 맨 앞에 있는 값이 루트, 후위는 맨 뒤에 있는 값이 루트

## 1. 전위순회(preorder traversal)

- 루트 -> 왼 -> 오

![전위순회](https://user-images.githubusercontent.com/70371342/222063709-03d4178b-e30e-4e8a-b1c3-9916ed1807f6.png)

- 출력: A-B-D-H-E-I-J-C-F-G-K

```
function preorder(v) {
  if (v >= 8) return;        // 종점; 8이상이 되면 종료
  answer += v + '';          // 루트 출력
  preorder(n * 2);           // 왼쪽 이동
  preorder(n * 2 + 1);       // 오른쪽 이동
}
```

## 2. 중위순회(inorder traversal)

- 왼 -> 루트 -> 오
- 만약 자기 자신에게 왼쪽 노드가 있다면 자기 처리를 미루고 왼쪽부터 이동 후 루트 이동 후 오른쪽 이동

![중위순회](https://user-images.githubusercontent.com/70371342/222063725-138d74e5-1a28-4736-b489-5464396d1c51.png)

- 출력: H-D-B-I-E-J-A-F-C-G-K

```
function inorder(v) {
  if (v >= 8) return;        // 종점; 8이상이 되면 종료
  preorder(n * 2);           // 왼쪽 이동
  answer += v + '';          // 루트 출력
  preorder(n * 2 + 1);       // 오른쪽 이동
}
```

## 3. 후위순회(postorder traversal)

- 왼 -> 오 -> 루트
- 만약 자기 자신에게 왼쪽 노드가 있다면 자기 처리를 미루고 왼쪽부터 이동 후 오른쪽 이동 후 루트 이동

![후위순회](https://user-images.githubusercontent.com/70371342/222063741-d72ce9c8-b2aa-413e-99de-5d2c5c9b0f37.png)

- 출력: H-D-I-J-E->B->F->K->G->C->A

```
function postorder(v) {
  if (v >= 8) return;        // 종점; 8이상이 되면 종료
  preorder(n * 2);           // 왼쪽 이동
  preorder(n * 2 + 1);       // 오른쪽 이동
  answer += v + '';          // 루트 출력
}
```

# 레벨순회(큐 기반)

- 노드를 레벨 순으로 검사
- 너비 우선 탐색과 동작이 유사, 큐 기반, 순환X

1. 루트를 큐에 넣고, 데이터 하나 삭제 -> 출력
2. 루트와 연결되어 있는 자식노드 두 개를 큐에 넣음
3. while -> 큐가 비어있지 않으므로 true, 큐에서 데이터 하나 삭제 -> 출력
4. 삭제된 데이터와 연결되어 있는 자식노드 두 개를 큐에 넣음

- 3, 4번 while문 돌면서 반복
- 각 레벨을 순서대로 탐방하는 결과를 가지게 됨.
