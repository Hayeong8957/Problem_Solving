# 슬라이딩 윈도우(Sliding window)

## 슬라이딩 윈도우란?

- 창문을 한쪽으로 밀면서 문제를 푸는 것과 모양이 유사해서 붙여진 이름
- 특정 범위(윈도우)가 있을 때 윈도우 내부 요소의 값을 이용하여 문제를 풀이하는 알고리즘
- 투포인터처럼 구간을 훑으면서 지나간다는 공통점은 있으나 어느 순간에도 그 구간의 넓이가 동일하다는 차이점이 있다.
- 구간의 넓이가 주어졌을 때는 슬라이딩 윈도우로 문제를 풀면 된다.
- 고정적인 범위를 탐색할 때 유용, 중복으로 연산을 제거하면서 효율을 높일 수 있다.

## 예제

![image](https://user-images.githubusercontent.com/70371342/213846411-63fceeea-cb7d-416b-8d2a-d7642d1ecc6e.png)

[1, 3, 2, 6, -1, 4, 1, 8, 2]라는 배열이 있는데, 연속적인 5개의 숫자의 합이 최대의 값을 구한다고 가정

1. [1, 3, 2, 6, -1], 4, 1, 8, 2 | 합: 11
2. 1, [3, 2, 6, -1, 4], 1, 8, 2 | 합: 14
3. 1, 3, [2, 6, -1, 4, 1], 8, 2 | 합: 12
4. 1, 3, 2, [6, -1, 4, 1, 8], 2 | 합: 18
5. 1, 3, 2, 6, [-1, 4, 1, 8, 2] | 합: 14

→ 4번이 최대이다. 공통된 패턴을 구해 코드로 구현해야 한다.
→ 첫번째로 1 + 3 + 2 + 6 + (-1) 를 계산을 하고
두번째로 3 + 2 + 6 + (-1) + 4 를 계산하면 되는데
중복 부분 3 + 2 + 6 + (-1) 이 생기게 된다.
→ 중복적인 경우를 코드로 구현한다면 처음 계산된 합에서 맨 앞 인덱스를 빼고, 마지막 인덱스를 더하여 계산하는 방식으로 구현한다.

## 코드(javascript)

- 먼저 temp에 0번 인덱스부터 4번 인덱스까지의 합을 지정한다.
- 이제 5번 인덱스부터 탐색을 진행하고 temp에 현재 인덱스를 더하고 현재 인덱스의 -5를 한 인덱스를 빼준다.
- 계산 후 최대값 비교

```
let arr = [1, 3, 2, 6, -1, 4, 1, 8, 2];
let N = arr.length;
let K = 5;
let tempSum = maxSum = 0;

if(arr.length < K) return null;

for(let i = 0; i < K; i++) { //  K가지 숫자를 maxSum에 더함
  maxSum += arr[i]
}

tempSum = maxSum;  // tempSum에 maxSum을 복사해 보관

for(let i = K; i < N; i++) {                // maxSum까지 더했던 인덱스의 다음 인덱스를 시작점으로 loop
  tempSum = tempSum - arr[i - K] + arr[i];  // 바로 앞 인덱스 값을 빼고, 바로 다음 인덱스 값을 더한다.
  maxSum = Math.max(maxSum, tempSum);       // maxSum과 tempSum을 비교해서 더 큰 값을 maxSum에 할당한다.
}

console.log("최대값",maxSum);

```
