<!-- (투포인터 문제)
# 내 풀이
오름차순 정렬 두 배열 합쳐 오름차순 출력
합쳐 -> arr1순회하며 요소들 answer에 push
     -> arr2순회하며 요소들 answer에 push
오름차순 -> sort((a,b) => a-b)

# 시간 복잡도를 생각했을 때는 내 풀이대로 푸는 것이 아니다!!!!!
- sort함수가 호출되기만 해도, n개만 호출을 해도 nlogn의 시간복잡도를 가진다...

# 강의 풀이
- 두개의 포인터 변수 p1, p2를 가지고 쭉 탐색한다.
- 시간 복잡도: O(n+m)
1. 두개의 포인터들은 각각 arr1, arr2의 0번째 인덱스를 가리킨다.
2. 각각 가리키는 인덱스를 비교해서 둘 중 작은 값을 answer라는 배열에 push를 한다.
3. 넣은 값이 속한 배열의 인덱스를 1씩 증가한다.
4. 한 쪽 배열이 다 탐색이 되면 일단 비교하는 것은 멈추고
5. 남은 배열에서 가리키고 있는 지점부터 끝까지 다 answer에 때려 박아.

function solution(arr1, arr2) {
  let answer=[];
  let n=arr1.length;
  let m=arr2.length;
  let p1=p2=0;

  while(p1<n && p2<m) {
    if(arr1[p1] <= arr2[p2]) answer.push(arr1[p1++]);
    else answer.push(arr2[p2++]);
  }
  while(p1<n) answer.push(arr1[p1++]);
  while(p2<m) answer.push(arr2[p2++]);
  return answer;
}

 -->
<html>
  <head>
    <meta charset="UTF-8" />
    <title>출력결과</title>
  </head>
  <body>
    <script>
      function solution(arr1, arr2) {
        let answer = [];
        for (x of arr1) {
          answer.push(x);
        }
        for (x of arr2) {
          answer.push(x);
        }
        answer.sort((a, b) => a - b);

        return answer;
      }

      let a = [1, 3, 5];
      let b = [2, 3, 6, 7, 9];
      console.log(solution(a, b));
    </script>
  </body>
</html>
