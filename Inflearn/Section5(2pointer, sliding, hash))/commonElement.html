<!-- 
# 내 풀이 ==========> 내 생각은 틀렸어!!
arr1, arr2를 가리키는 인덱스 p1, p2가 있어
1. arr1을 가리키는 인덱스 p1이 있잖아? 걔 0, 1, 2..한 번 가리킬 때
arr2를 가리키는 인덱스 p2가 존나게 뺑이쳐 
2.p1 => 0, p2 => 0, 1, 2, 3, 4, ...... 다 순회를 하는 거지
3. 시간 복잡도 : n*m => O(mN) 
4. 오름차순 정렬을 하려면 sort를 사용하면 좋을텐데 
sort의 시간 복잡도는 아까처럼 O(N^2)
5. 다른 오름차순 정렬 방법이 있냐 -> 오름차순 정렬할 때도 투포인터 사용해봐?

# 강사 풀이
교집합을 오름차순으로 출력해라!
1. 첫번째 집합과 두번째 집합을 정렬하고 나서 투포인터 알고리즘
2-1. 값이 같을 때 push하고 둘 다 포인터 증가시킨
2-2. 작은 값을 가리키는 포인터를 증가시킴 p1이 작으면 p1증가, p2가 작으면 p2증가
3. 시간 복잡도: O(n+m)
 -->
<html>
  <head>
    <meta charset="UTF-8" />
    <title>출력결과</title>
  </head>
  <body>
    <script>
      function solution(arr1, arr2) {
        let answer = [];
        let p1 = (p2 = 0);
        let n = arr1.length;
        let m = arr2.length;
        arr1.sort((a, b) => a - b);
        arr2.sort((a, b) => a - b);

        while (p1 < n && p2 < m) {
          if (arr1[p1] === arr2[p2]) {
            answer.push(arr1[p1++]);
            p2++;
          } else if (arr1[p1] < arr2[p2]) p1++;
          else p2++;
        }
        return answer;
      }

      let a = [1, 3, 9, 5, 2];
      let b = [3, 2, 5, 7, 8];
      console.log(solution(a, b));
    </script>
  </body>
</html>
