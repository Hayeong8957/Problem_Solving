# 힙 정렬(heapSort)

- 힙 정렬은 힙 트리 구조를 이용하는 정렬 방법이다. 따라서 가장 먼저 힙(Heap)이 무엇인지 알아야 한다.
- 내림차순 정렬을 위해서는 최대 힙을 구성하고 오름차순 정렬을 위해서는 최소 힙을 구성하면 된다.
- 과정 설명
  1. 정렬해야 할 n개의 요소들로 최대 힙(완전 이진 트리 형태)을 만든다.
  2. 만들어준 최대힙의 루트노드 값과 맨끝 노드 값을 비교한다. 만약 루트 노드 값이 맨 끝 노드 값보다 크면 서로 값을 스와핑 한다.
  3. 맨 끝 노드 값은 자리를 확정 받은 상태, 다음 힙 생성 알고리즘을 적용시킬 때 굳이 비교할 필요가 없기에 이제 마지막 인덱스 값을 1 감소시켜준다.
  4. 남은 배열을 다시 최대 힙 구조로 만든다.
  5. 2~4 과정을 배열의 크기가 1이 될 때까지 반복한다.

- 장점
  1. 시간 복잡도가 O(nlogn)으로 좋은 편 : 모든 원소에 힙 정렬을 적용시키기 때문에 N(데이터 수) * logN(힙 생성 알고리즘)이 되는 것
  2. 힙 정렬이 가장 유용한 경우는 전체 자료를 정렬하는 것이 아니라 가장 큰 값 몇개만 필요할 때이다. 

## 힙(Heap)

힙은 최솟값이나 최댓값을 빠르게 찾아내기 위해 완전 이진 트리를 기반으로 하는 트리이다. <br/>
힙 정렬을 하기 위해서는 정해진 데이터가 힙 구조를 가지도록 만들어야 한다.
- 힙은 1차원 배열로 쉽게 구현될 수 있다.
- 최대 힙: 부모 노드 > 자식노드, 무조건 부모 노드가 자식 노드보다 큰 이진 트리
<img width="551" alt="image" src="https://user-images.githubusercontent.com/70371342/229344693-c4190550-c9aa-48f2-b266-3e27c049974c.png">

## 힙 생성 알고리즘

힙 생성 알고리즘은 특정한 '하나의 노드'에 대해 수행하는 것, 해당 **'하나의 노드를 제외하고는 최대 힙이 구성되어 있는 상태'** 라고 가정을 하는 특징이 있다.
<br/>
**특정한 노드의 두 자식 중에서 더 큰 자식과 자신의 위치를 자식이 더이상 존재하지 않을 때까지 바꾸는 알고리즘**이다.<br/>
- 힙 생성 알고리즘은 전체 트리 구조를 가지도록 만든다는 점에서 중요한 알고리즘
- 한 번 자식노드로 내려갈 때마다 노드의 개수가 2배씩 증가한다는 점에서 O(log N)이다.
  - 예를 들어, 데이터의 개수가 1024개라면, 대략 10번 정도만 내려가도 된다는 것이다.
  
## 구현
### python
```python
# 힙 조건을 만족하도록 노드를 재배치
def downheap(i, size) :
    while 2*i <= size :
        k = 2*i
        if k < size and a[k] < a[k+1] :       # 1
            k += 1                            
        if a[i] >= a[k] :                     # 2
            break                             
        a[i], a[k] = a[k] , a[i]              # 3
        i = k                                 # 4

# 배열을 최대 힙 구조로 만드는 함수
def create_heap(a) :
    hsize = len(a) - 1
    for i in reversed(range(1, hsize//2+1)) :
        downheap(i, hsize)

# 주어진 배열을 힙정렬하는 함수, 
# 루트 노드의 값을 맨 뒤로 이동하고 배열의 크기를 줄이고 남은 배열 다시 최대 힙 구조 만드는 과정을 배열의 크기가 1이 될 때까지 반복
def heap_sort(a) :
    N = len(a) - 1
    for i in range(N - 1) :
        a[1], a[N] = a[N], a[1]
        downheap(1, N-1)
        N -= 1
        # step 출력 위한 것
        print(f"sept{i+1} = {a}")

def print_val(a) :
    for i in range(1, len(a))
        print(a[i], end=" ")
    print()

a = [5,3,8,4,9,1,6,2,7]
print("정렬 전:\t", end="")
print_val(a)

create_heap(a)
print("최대 힙:\t", end="")
print_val(a)

heap_sort(a)
print("정렬 후:\t", end="")
print_val(a)
```
1 : k가 검색 범위 안이고, 왼쪽 자식 노드 < 오른쪽 자식 노드이면, <br/>
부모노드와 비교할 자식노드를 오른쪽 자식노드로 지정. (default; k는 왼쪽 노드이며, 왼쪽노드 > 오른쪽노드)<br/>
2 : downheap해야 할 i와 자식노드 비교해서 현재 i값이 더 크면 downheap할 필요가 없고 자기 자리를 찾은 것이므로 while문 탈출<br/>
3 : 위의 조건에 부합하지 않으면 현재노드가 자식노드보다 작다는 것이므로 원소 위치 상호교환<br/>
4 : i(부모노드인덱스)에 k(자식노드인덱스)를 대입하여 그 자식노드가 이제 부모가 되어 그 밑의 노드들과 비교<br/>

```
정렬 전:	3 8 4 9 1 6 2 7 
최대 힙:	9 8 6 7 1 4 2 3 
sept1 = [5, 8, 7, 6, 3, 1, 4, 2, 9]
sept2 = [5, 7, 3, 6, 2, 1, 4, 8, 9]
sept3 = [5, 6, 3, 4, 2, 1, 7, 8, 9]
sept4 = [5, 4, 3, 1, 2, 6, 7, 8, 9]
sept5 = [5, 3, 2, 1, 4, 6, 7, 8, 9]
sept6 = [5, 2, 1, 3, 4, 6, 7, 8, 9]
sept7 = [5, 1, 2, 3, 4, 6, 7, 8, 9]
정렬 후:	1 2 3 4 6 7 8 9
```
