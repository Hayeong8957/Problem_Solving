# 힙 정렬(heapSort)

- 힙 정렬은 힙 트리 구조를 이용하는 정렬 방법이다. 따라서 가장 먼저 힙(Heap)이 무엇인지 알아야 한다.
- 내림차순 정렬을 위해서는 최대 힙을 구성하고 오름차순 정렬을 위해서는 최소 힙을 구성하면 된다.
- 과정 설명

  1. 정렬해야 할 n개의 요소들로 최대 힙(완전 이진 트리 형태)을 만든다.
  2. 만들어준 최대힙의 루트노드 값과 맨끝 노드 값을 비교한다. 만약 루트 노드 값이 맨 끝 노드 값보다 크면 서로 값을 스와핑 한다.
  3. 맨 끝 노드 값은 자리를 확정 받은 상태, 다음 힙 생성 알고리즘을 적용시킬 때 굳이 비교할 필요가 없기에 이제 마지막 인덱스 값을 1 감소시켜준다.
  4. 남은 배열을 다시 최대 힙 구조로 만든다.
  5. 2~4 과정을 배열의 크기가 1이 될 때까지 반복한다.

- 장점
  1. 시간 복잡도가 O(nlogn)으로 좋은 편 : 모든 원소에 힙 정렬을 적용시키기 때문에 N(데이터 수) \* logN(힙 생성 알고리즘)이 되는 것
  2. 힙 정렬이 가장 유용한 경우는 전체 자료를 정렬하는 것이 아니라 가장 큰 값 몇개만 필요할 때이다.

## 힙(Heap)

힙은 최솟값이나 최댓값을 빠르게 찾아내기 위해 완전 이진 트리를 기반으로 하는 트리이다. <br/>
힙 정렬을 하기 위해서는 정해진 데이터가 힙 구조를 가지도록 만들어야 한다.

- 힙은 1차원 배열로 쉽게 구현될 수 있다.
- 최대 힙: 부모 노드 > 자식노드, 무조건 부모 노드가 자식 노드보다 큰 이진 트리
  <img width="551" alt="image" src="https://user-images.githubusercontent.com/70371342/229344693-c4190550-c9aa-48f2-b266-3e27c049974c.png">

## 힙 생성 알고리즘

힙 생성 알고리즘은 특정한 '하나의 노드'에 대해 수행하는 것, 해당 **'하나의 노드를 제외하고는 최대 힙이 구성되어 있는 상태'** 라고 가정을 하는 특징이 있다.
<br/>
**특정한 노드의 두 자식 중에서 더 큰 자식과 자신의 위치를 자식이 더이상 존재하지 않을 때까지 바꾸는 알고리즘**이다.<br/>

- 힙 생성 알고리즘은 전체 트리 구조를 가지도록 만든다는 점에서 중요한 알고리즘
- 한 번 자식노드로 내려갈 때마다 노드의 개수가 2배씩 증가한다는 점에서 O(log N)이다.
  - 예를 들어, 데이터의 개수가 1024개라면, 대략 10번 정도만 내려가도 된다는 것이다.

## 구현

### python

```python
# 힙 조건을 만족하도록 노드를 재배치
def downheap(i, size) :
    while 2*i <= size :
        k = 2*i
        if k < size and a[k] < a[k+1] :       # 1
            k += 1
        if a[i] >= a[k] :                     # 2
            break
        a[i], a[k] = a[k] , a[i]              # 3
        i = k                                 # 4

# 배열을 최대 힙 구조로 만드는 함수
# 주어진 배열 크기를 이용하여, 루트 노드의 자식 노드들만 downheap 함수 호출
# 루트 노드의 자식 노드들은 배열의 뒤쪽에 위치하기 때문에, 역순으로 루트 노드의 자식 노드들부터 downheap함수를 호출
def create_heap(a) :
    hsize = len(a) - 1
    for i in reversed(range(1, hsize//2+1)) :
        downheap(i, hsize)

# 주어진 배열을 힙정렬하는 함수,
# 루트 노드의 값을 맨 뒤로 이동하고 배열의 크기를 줄이고 남은 배열 다시 최대 힙 구조 만드는 과정을 배열의 크기가 1이 될 때까지 반복
def heap_sort(a) :
    N = len(a) - 1
    for i in range(N - 1) :
        a[1], a[N] = a[N], a[1]
        downheap(1, N-1)
        N -= 1
        # step 출력 위한 것
        print(f"sept{i+1} = {a}")

def print_val(a) :
    for i in range(1, len(a))
        print(a[i], end=" ")
    print()

a = [5,3,8,4,9,1,6,2,7]
print("정렬 전:\t", end="")
print_val(a)

create_heap(a)
print("최대 힙:\t", end="")
print_val(a)

heap_sort(a)
print("정렬 후:\t", end="")
print_val(a)
```

1 : k가 검색 범위 안이고, 왼쪽 자식 노드 < 오른쪽 자식 노드이면, <br/>
부모노드와 비교할 자식노드를 오른쪽 자식노드로 지정. (default; k는 왼쪽 노드이며, 왼쪽노드 > 오른쪽노드)<br/>
2 : downheap해야 할 i와 자식노드 비교해서 현재 i값이 더 크면 downheap할 필요가 없고 자기 자리를 찾은 것이므로 while문 탈출<br/>
3 : 위의 조건에 부합하지 않으면 현재노드가 자식노드보다 작다는 것이므로 원소 위치 상호교환<br/>
4 : i(부모노드인덱스)에 k(자식노드인덱스)를 대입하여 그 자식노드가 이제 부모가 되어 그 밑의 노드들과 비교<br/>

```
정렬 전:   5 3 8 4 9 1 6 2 7
최대 힙:   9 7 8 4 5 1 6 2 3
sept1 = [9, 7, 8, 4, 5, 1, 6, 2, 3]
sept2 = [8, 7, 6, 4, 5, 1, 3, 2, 9]
sept3 = [7, 5, 6, 4, 2, 1, 3, 8, 9]
sept4 = [6, 5, 3, 4, 2, 1, 7, 8, 9]
sept5 = [5, 4, 3, 2, 1, 6, 7, 8, 9]
sept6 = [4, 2, 3, 1, 5, 6, 7, 8, 9]
sept7 = [3, 2, 1, 4, 5, 6, 7, 8, 9]
sept8 = [2, 1, 3, 4, 5, 6, 7, 8, 9]
정렬 후:   1 2 3 4 5 6 7 8 9

```

### javascript

```javascript
// 최대 힙 구성: 주어진 인덱스 i를 루트로 하는 서브트리를 최대 힙으로 만드는 함수
// size: 배열의 크기
// k는 i의 왼쪽 자식 노드, 만약 오른쪽 자식 노드가 더 크다면 k를 오른쪽 자식 노드의 인덱스로 갱신
// a[i]가 a[k] 보다 크다면 이미 최대 힙이 되어있으므로 반복문을 종료
// 그렇지 않다면 arr[i] & arr[k] 스왑하고 i를 k로 갱신하여 최대 힙을 만들기 위해 계속해서 반복한다.
function downheap(i, size, arr) {
  while (2 * i + 1 <= size) {
    let k = 2 * i + 1;
    if (k + 1 <= size && arr[k] < arr[k + 1]) {
      k += 1;
    }
    if (arr[i] >= arr[k]) {
      break;
    }
    [arr[i], arr[k]] = [arr[k], arr[i]];
    i = k;
  }
}

// 최대 힙에서 가장 큰 값을 추출하여 배열의 뒷부분부터 채워 나가기
// 배열의 중간부터 시작하여 루트노드까지 모든 서브트리를 최대 힙으로 만든다.
function createHeap(arr) {
  const size = arr.length;
  for (let i = Math.floor(size / 2) - 1; i >= 0; i--) {
    downheap(i, size - 1, arr);
  }
}

// 최대 힙으로 만든 다음, 배열의 마지막 요소부터 첫 번째 요소까지 downheap함수를 호출하여
// 최대 힙에서 가장 큰 값을 추출하고, 해당 값을 배열의 마지막 요소와 교환한다.
// 그리고 추출한 값은 더 이상 정렬할 필요가 없으므로 size변수를 감소시킨다.
function heapSort(arr) {
  createHeap(arr);
  let size = arr.length - 1;
  for (let i = 0; i < size; i++) {
    [arr[0], arr[size - i]] = [arr[size - i], arr[0]];
    downheap(0, size - i - 1, arr);
    // size는 현재 배열의 길이, i는 이미 정렬된 부분의 길이
    // 정렬되지 않은 부분의 길이는 size - i - 1
  }
  return arr;
}

const arr = [5, 3, 8, 4, 9, 1, 6, 2, 7];
console.log('정렬 전:', arr);
console.log('정렬 후:', heapSort(arr));
```
