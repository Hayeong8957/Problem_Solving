<!-- [선택 정렬]
- 오른쪽 리스트에서 가장 작은 숫자를 선택해서 
  왼쪽 리스트의 맨 뒤로 이동하는 작업 반복
- 비효율적, 자료 이동 갯수가 정해짐

1. for i=0~len-1) 현재 index부터 마지막 index까지 최솟값의 index를 찾아냄
-> len-1하는 이유는 마지막 요소는 정렬이 되었다고 생각하고 회전수를 포함하지 않음
-> 이것 대신 내부 반복문을 for j=i+1 ~ len 으로 해도 됨

2. i번째 요소가 가장 작다는 전제조건 => 현재 index를 minIdx 변수에 담아
3. for j=i~len) 
3-1. minIdx이 현재 index의 값보다 크면 minIdx = j
4. 최솟값의 index와 현재 index에 있는 값 상호 교환

# arr[i], arr[minIdx] = arr[minIdx], arr[i];
-> 파이썬의 swap연산에 익숙해져서 자스도 이렇게 작성해버림;

# javascript swap연산 => 구조 분해 할당
[a, b] = [b, a]

# 강의 답안
function solution(arr){
    let answer=arr;
    for(let i=0; i<arr.length; i++){
        let idx=i;
        for(let j=i+1; j<arr.length; j++){
            if(arr[j]<arr[idx]) idx=j;
        }
        [arr[i], arr[idx]] = [arr[idx], arr[i]];
    } 
    return answer;
}
-->

<html>
  <head>
    <meta charset="UTF-8" />
    <title>출력결과</title>
  </head>
  <body>
    <script>
      function solution(arr) {
        let answer = arr;
        for (let i = 0; i < arr.length - 1; i++) {
          let minIdx = i;
          for (let j = i; j < arr.length; j++) {
            if (arr[minIdx] > arr[j]) minIdx = j;
          }
          [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
        }
        return answer;
      }

      let arr = [13, 5, 11, 7, 23, 15];
      console.log(solution(arr));
    </script>
  </body>
</html>
