const fs = require('fs');
const filePath =
  process.platform === 'linux'
    ? '/dev/stdin'
    : '/Users/shinhayeong/Desktop/Problem_Solving/test.txt';
const [N, K] = fs.readFileSync(filePath).toString().trim().split(' ');

// 예시 만약에 K가 3이라고 하고 N이 20이라고 하면,
// ? + ? + X = 20 이 되어야 하고
// X가 만약 0이라면 이전까지 합은 20이고, 1이라면 이전까지 합은 19이고, 2라면 18...
// 즉 (20-X) + X = 20이라는 것, 이전까지의 숫자 합에 N이 될 수 있는 임의의 값을 더한 것
// 더 작은 값으로 K = 2, N = 2라고 할 떄,
// k-1로 0을 만드는 경우, k-1개로 1을 만드는 경우, k-1개로 2를 만드는 경우를 모두 고려해야 한다.
// 0을 만들었다면 2를 더하면 2가 되고, 1을 만들었다면 1을 더하면 2가 되고, 2를 만들었다면 0을 더하면 2가 되므로, 세경우를 모두 합하면 된다.
// 따라서 DP[2][2] = DP[1][0] + DP[1][1] + DP[1][2]이렇게 구할 수 있다.
// 점화식 : DP[K][N] = DP[K-1][0] + DP[K-1][1] + ... + DP[K-1][N]
// 위 점화식 말고 예외 상황들
// 1. dp[0][i]은 무조건 0이다. -> 0개로 N을 만들 수 있는 방법은 0이다.
// 2. dp[1][i]는 무조건 1이다. -> 숫자중 하나 뽑아 N을 만드는 방법은 한가지 뿐이다.
// 3. dp[i][0]또한 1이다. -> 0을 만드는 방법은 0 하나를 택하는 방법 하나이기 떄문이다.

// [DP 테이블 <- MOD로 나누기 전]
//   0   1   2   3   4
// 0 0   0   0   0   0
// 1 1   1   1   1   1
// 2 1   2   3   4   5
// 3 1   3   6   10  15
// 4 1   4   10  20  35
// dp[K][N] = dp[K-1][0] + dp[K-1][1] + ... + dp[K-1][N-1] + dp[K-1][N]
// 인데 dp[K-1][0] + dp[K-1][1] + ... + dp[K-1][N-1] = dp[K][N-1] 이라고 볼 수 있다.
// 즉, dp[K][N] = dp[K][N-1] + dp[K-1][N] 로 일반화 시킬 수 있다.
const MOD = 1000000000; // 문제에서 요구한 나머지 값
const dp = Array.from({ length: K + 1 }, () => Array(N + 1).fill(0));

// i개의 숫자로 0을 만드는 방법은 1가지
for (let i = 0; i <= K; i++) {
  dp[i][0] = 1;
}

for (let k = 1; k <= K; k++) {
  for (let n = 1; n <= N; n++) {
    dp[k][n] = (dp[k][n - 1] + dp[k - 1][n]) % MOD;
  }
}

console.log(dp[K][N]);
